#![forbid(unsafe_code)]

mod errors;
mod parse_attrs;

use errors::Errors;
use parse_attrs::TypeAttrs;
use proc_macro2::TokenStream;
use quote::{format_ident, quote, ToTokens};

/// Derive macro generating VennDB functionality for this struct.
#[proc_macro_derive(VennDB, attributes(venndb))]
pub fn venndb(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let ast = syn::parse_macro_input!(input as syn::DeriveInput);
    let gen = impl_from_args(&ast);
    gen.into()
}

/// Transform the input into a token stream containing any generated implementations,
/// as well as all errors that occurred.
fn impl_from_args(input: &syn::DeriveInput) -> TokenStream {
    let errors = &Errors::default();
    let type_attrs = &TypeAttrs::parse(errors, input);
    let mut output_tokens = match &input.data {
        syn::Data::Struct(ds) => impl_from_args_struct(
            errors,
            &input.vis,
            &input.ident,
            type_attrs,
            &input.generics,
            ds,
        ),
        syn::Data::Enum(_) => {
            errors.err(input, "`#[derive(VennDB)]` cannot be applied to enums");
            TokenStream::new()
        }
        syn::Data::Union(_) => {
            errors.err(input, "`#[derive(VennDB)]` cannot be applied to unions");
            TokenStream::new()
        }
    };
    errors.to_tokens(&mut output_tokens);
    output_tokens
}

/// Implements `VennDB` for a `#[derive(VennDB)]` struct.
fn impl_from_args_struct(
    errors: &Errors,
    vis: &syn::Visibility,
    name: &syn::Ident,
    type_attrs: &TypeAttrs,
    _generic_args: &syn::Generics,
    ds: &syn::DataStruct,
) -> TokenStream {
    let _fields = match &ds.fields {
        syn::Fields::Named(fields) => fields,
        syn::Fields::Unnamed(_) => {
            errors.err(
                &ds.struct_token,
                "`#![derive(VennDB)]` is not currently supported on tuple structs",
            );
            return TokenStream::new();
        }
        syn::Fields::Unit => {
            errors.err(
                &ds.struct_token,
                "#![derive(VennDB)]` cannot be applied to unit structs",
            );
            return TokenStream::new();
        }
    };

    let name_db = match &type_attrs.name {
        Some(name) => format_ident!("{}", name.value()),
        None => format_ident!("{}DB", name),
    };

    let name_query_builder = format_ident!("{}QueryBuilder", name_db);

    let db_doc = format!(
        "An in-memory database for storing instances of [`{}`], generated by `#[derive(VennDB)]`.",
        name
    );
    let query_doc = format!(
        "A query builder for querying instances of [`{}`] in a [`{}`] database.",
        name, name_db
    );
    quote! {
        #[doc=#db_doc]
        #vis struct #name_db {
            rows: Vec<#name>,
        }

        impl #name_db {
            #vis fn new() -> Self {
                Self {
                    rows: Vec::new(),
                }
            }

            /// Return the number of rows in the database.
            #vis fn len(&self) -> usize {
                self.rows.len()
            }

            /// Return `true` if the database is empty.
            #vis fn is_empty(&self) -> bool {
                self.rows.is_empty()
            }

            /// Query the database using a query builder.
            #vis fn query(&self) -> #name_query_builder {
                #name_query_builder { db: self }
            }
        }

        impl Default for #name_db {
            fn default() -> Self {
                Self::new()
            }
        }

        #[doc=#query_doc]
        #vis struct #name_query_builder<'a> {
            db: &'a #name_db,
        }
    }
}
